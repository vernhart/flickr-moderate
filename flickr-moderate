#!/usr/bin/env python3

from common import *        # common function library
from pprint import pprint   # for debugging


def groupSummaryIcons(groups):
    "Generate a summary of the various view/fav groups suitable for their description field"

    summary = ["No nudity or pornography allowed!! These pictures ",
        "will be removed without explaination.\n\n",
        "In order to keep the pools at a reasonable size, so everybody's ",
        "pictures can be seen and favorited, please <b>keep each picture ",
        "in ONLY 1 &quot;Views: <i>xx</i>&quot; and 1 &quot;Favorites: ",
        "<i>xx</i>&quot; group at a time.</b> (2 groups total for each picture.)\n"]

    summary.append('\n<b>*** Views Groups ***</b>\n')

    for mincount, info in sorted(groups['views'].items()):
        summary.append('<a href="http://www.flickr.com/groups/views%s/"><img src="%s"></a> '
            % (mincount, info['icon']))

    summary.append('\n<b>*** Favorites Groups ***</b>\n')

    for mincount, info in sorted(groups['favs'].items()):
        summary.append('<a href="http://www.flickr.com/groups/favs%s/"><img src="%s"></a> '
            % (mincount, info['icon']))

    return(''.join(summary))

def groupSummaryDots(groups):
    "Generate a summary of the various view/fav groups suitable for their description field"

    summary = ["\n\nNo nudity or pornography allowed!! These pictures ",
        "will be removed without explaination.\n\n",
        "In order to keep the pools at a reasonable size, so everybody's ",
        "pictures can be seen and favorited, please <b>keep each picture ",
        "in ONLY 1 &quot;Views: <i>xx</i>&quot; and 1 &quot;Favorites: ",
        "<i>xx</i>&quot; group at a time.</b> (2 groups total for each picture.)\n"]

    max = 0
    for mincount, info in groups['views'].items():
        if info['pool_count'] > max: max = info['pool_count']

    summary.append('\n<b>*** Views Groups ***</b>\n')

    for mincount, info in sorted(groups['views'].items()):
        summary.append('<a href="http://www.flickr.com/groups/views%s/">%s</a> %s %d Photos\n'
            % (mincount, info['name'], '.' * round(info['pool_count']/max*100), info['pool_count']))

    max = 0
    for mincount, info in groups['favs'].items():
        if info['pool_count'] > max: max = info['pool_count']

    summary.append('\n<b>*** Favorites Groups ***</b>\n')

    for mincount, info in sorted(groups['favs'].items()):
        summary.append('<a href="http://www.flickr.com/groups/favs%s/">%s</a> %s %d Photos\n'
            % (mincount, info['name'], '.' * round(info['pool_count']/max*100), info['pool_count']))

    return(''.join(summary))

def setGroupDescription(group, summary):
    "Sets the given group's description to a view/fav line plus the boilerplate summary"
    # this function doesn't do anythig. there's no way to set a group's description via the api

    if "Favorites:" in group['name']:
        mincount = group['name'][10:]
        what = 'favorites'
    elif "Views:" in group['name']:
        mincount = group['name'][6:]
        what = 'views'

    text = ''.join(("This group is for any photo with <b>at least %s %s</b> when entering the pool.\n"
        % (mincount, what), summary))

    #print(text)

    return


def scanGroups(flickr, db, groups):
    "Scans through fav/views groups and removes images that don't qualify"

    prevmin = 9999999999
    seenphotos = []
    for mincount, info in sorted(groups['views'].items(), reverse=True):
        graduates = {}
        removephotos = {}
        # only work with groups we can administer
        if info['admin']:
            print('===== %s =====' % info['name'])
            pages = 1
            i = 0
            while i < pages:
                i=i+1
                photos = flickr.groups.pools.getPhotos(group_id=info['nsid'], page=i, extras='views,count_faves,url_n')
                #pprint(photos)
                pages = photos['photos']['pages']
                for photo in photos['photos']['photo']:

                    # sometimes the url_n url doesn't get set for some reason
                    # let's construct it manually
                    if not 'url_n' in photo:
                        photo['url_n'] = 'https://farm%s.staticflickr.com/%s/%s_%s_n.jpg' % (photo['farm'], photo['server'], photo['id'], photo['secret'])

                    photo['url'] = "https://www.flickr.com/photos/%s/%s" % (photo['owner'], photo['id'])

                    removed = False
                    # if it doesn't have enough views, remove immediately
                    if int(photo['views']) < mincount:
                        print("Should not be in this group!! %s %s" % (photo['views'], photo['url']))
                        removephotos[photo['id']] = info['nsid']
                        removed = True

                    # if we've seen this photo before, it must already be in a higher group
                    if not removed and photo['id'] in seenphotos:
                        print("Already in another view group: %s" % photo['url'])
                        removephotos[photo['id']] = info['nsid']
                        removed = True

                    # if we haven't seen it before but it has too many views, add to graduates list
                    if not removed and int(photo['views']) >= prevmin:
                        graduates[photo['id']] = photo

                    # if we haven't removed the photo, keep track of the ID
                    if not removed:
                        seenphotos.append(photo['id'])

            # now remove all the photos that don't belong
            for photo_id, group_id in removephotos.items():
                resp = flickr.groups.pools.remove(photo_id=photo_id, group_id=group_id)

            graduatePost(flickr, groups, group=info, photos=graduates)
            print("Seen photos: %d" % len(seenphotos))

        prevmin = mincount


    prevmin = 9999999999
    seenphotos = []
    for mincount, info in sorted(groups['favs'].items(), reverse=True):
        graduates = {}
        removephotos = {}
        # only work with groups we can administer
        if info['admin']:
            print('----- %s -----' % " ".join(info['name'].split()))
            pages = 1
            i = 0
            while i < pages:
                i=i+1
                photos = flickr.groups.pools.getPhotos(group_id=info['nsid'], page=i, extras='views,count_faves,url_n')
                pages = photos['photos']['pages']
                #print('page: %s/%s' % (i, pages))
                for photo in photos['photos']['photo']:

                    # sometimes the url_n url doesn't get set for some reason
                    # let's construct it manually
                    if not 'url_n' in photo:
                        photo['url_n'] = 'https://farm%s.staticflickr.com/%s/%s_%s_n.jpg' % (photo['farm'], photo['server'], photo['id'], photo['secret'])

                    photo['url'] = "https://www.flickr.com/photos/%s/%s" % (photo['owner'], photo['id'])

                    # set favs 
                    photo['favs'] = intOrString(photo['count_faves'])

                    removed = False
                    # if it doesn't have enough favs, remove immediately
                    if photo['favs'] < mincount:
                        print("Should not be in this group!! %s %s" % (photo['favs'], photo['url']))
                        removephotos[photo['id']] = info['nsid']
                        removed = True

                    # if we've seen this photo before, it must already be in a higher group
                    if not removed and photo['id'] in seenphotos:
                        print('Already in another favs group: %s' % photo['url'])
                        removephotos[photo['id']] = info['nsid']
                        removed = True

                    # if we haven't seen it before but it has too many favs, add to graduates list
                    if not removed and photo['favs'] >= prevmin:
                        graduates[photo['id']] = photo

                    # if we haven't removed the photo, keep track of the ID
                    if not removed:
                        seenphotos.append(photo['id'])

            # now remove all the photos that don't belong
            for photo_id, group_id in removephotos.items():
                resp = flickr.groups.pools.remove(photo_id=photo_id, group_id=group_id)

            graduatePost(flickr, groups, group=info, photos=graduates)
            print("Seen photos: %d" % len(seenphotos))

        prevmin = mincount
                        
    return


def getTopicID(flickr, group_id, subject):
    "Return the topic ID of the topic with the given subject in the supplied group."

    topic_id = 0

    # search the topics for the given subject
    pages = 1
    i = 0
    while i < pages:
        i=i+1
        topics = flickr.groups.discuss.topics.getList(group_id=group_id, page=i)
        pages = topics['topics']['pages']
        if int(topics['topics']['total']) > 0:
            for topic in topics['topics']['topic']:
                if topic['subject'] == subject:
                    topic_id = topic['id']
    return(topic_id)


def graduatePost(flickr, groups, group, photos):
    "Update topic post about photos that could be moved to the next higher group."

    subject = 'Proposed Graduation'
    topic_id = getTopicID(flickr, group_id=group['nsid'], subject=subject)
    # if we didn't find the topic, create it
    if topic_id == 0:
        resp = flickr.groups.discuss.topics.add(group_id=group['nsid'], subject=subject,
            message='This topic is an autogenerated message.\n\n' +
                'The replies to this post contain all the photos in this group' +
                ' that qualify for a higher group. This message will be updated periodically.' +
                ' If these photos are yours, feel free to remove them from this group and' +
                ' add them to the appropriate higher group. If you are an admin, do please' +
                ' invite these photos to the next higher group.')
        if resp['stat'] == 'ok':
            topic_id = resp['topic']['id']

    no_photos_message = "No photos ready for graduation."
    replies_to_delete = {}
    pages = 1
    i = 0
    while i <= pages:
        i=i+1
        replies = flickr.groups.discuss.replies.getList(group_id=group['nsid'], topic_id=topic_id, page=i)
        pages = replies['replies']['topic']['pages']
        #print("page %s/%s" % (i, pages))
        if 'reply' in replies['replies']:
            for reply in replies['replies']['reply']:
                if reply['message']['_content'] == no_photos_message:
                    if len(photos) > 0:
                        # if the reply is "no photos" but we have photos, delete the reply
                        resp = flickr.groups.discuss.replies.delete(group_id=group['nsid'], topic_id=topic_id, reply_id=reply['id'])
                    else:
                        # if we have no photos and the reply is "no photos", do nothing
                        return
                else:
                    # extract photo_id out of first url
                    m = re.search(r'/(?P<id>[0-9]+)[\'"]', reply['message']['_content'])
                    if m.group('id') in replies_to_delete:
                        # we have a duplicate photo in replies, delete immediately
                        print("deleting duplicate reply for %s" % m.group('id'))
                        resp = flickr.groups.discuss.replies.delete(group_id=group['nsid'], topic_id=topic_id, reply_id=reply['id'])
                    else:
                        replies_to_delete[m.group('id')] = reply['id']

    for photo_id, photo in sorted(photos.items()):
        if photo_id in replies_to_delete:
            # if photo already posted in replies, remove from delete list
            replies_to_delete.pop(photo_id)
        else:
            # else, post reply with photo
            if 'favs' in photo:
                # if we have favs, let's talk about favorites groups
                nextgroup = bestGroup(groups, favs=int(photo['favs']))
            else:
                # else talk about views groups
                nextgroup = bestGroup(groups, views=int(photo['views']))

            # attempt to invite the photo to the next group
            try:
                resp = flickr.groups.invite.photo.invite(group_id=nextgroup['nsid'], photo_id=photo['id'])
            except flickrapi.exceptions.FlickrError as err:
                print('flickrapi.execptions.FlickrError: {0} {1}'.format(err, group['nsid']))

            print('Posting reply for %s' % photo['url'])
            resp = flickr.groups.discuss.replies.add(group_id=group['nsid'], topic_id=topic_id,
                message=('<a href="https://www.flickr.com/photos/%s/%s"><img src="%s"></a> '
                    'Promote to <a href="https://www.flickr.com/groups/%s">%s</a>\n') %
                    (photo['owner'], photo['id'], photo['url_n'], nextgroup['nsid'], nextgroup['name']))

    for photo_id in replies_to_delete:
        print('Deleting reply for photo_id %s reply_id %s' % (photo_id, replies_to_delete[photo_id]))
        resp = flickr.groups.discuss.replies.delete(group_id=group['nsid'], topic_id=topic_id, reply_id=replies_to_delete[photo_id])

    if len(photos) <= 0:
        resp = flickr.groups.discuss.replies.add(group_id=group['nsid'], topic_id=topic_id,
            message=no_photos_message)

    return



def main():
    "Main function"

    cfg = loadConfig()
    flickr = auth(cfg['api_key'],cfg['api_secret'])
    db = redisAuth(cfg)

    groups = get_groups(flickr, cfg['user_nsid'])
    #pprint(groups['views'])

    #group_summary = groupSummaryIcons(groups)
    #print(group_summary)

    scanGroups(flickr, db, groups)


if __name__ == "__main__":
    main()

